!!!!! if a specific client was not part of a previous round and its not involved in round_metrics, then
when looking for the client in client_selector in (prev_round_start_time = round_timestamps[client_properties['container_name']].get("start", None))
there will be a key error, so we need to handle this case !!!!!

docker system prune -af !!!
docker-compose up -d grafana prometheus cadvisor mlflow_server
docker-compose up client1 client2 server

docker rm -f $(docker ps -a -q)

-https://github.com/tensorflow/privacy/blob/master/tensorflow_privacy/privacy/analysis/compute_dp_sgd_privacy_lib.py
 says about the formula for epsilon calculation from official tensorflow privacy library

- socat TCP-LISTEN:2375,reuseaddr,fork UNIX-CONNECT:/var/run/docker.sock

- https://github.com/google/cadvisor/blob/master/docs/storage/prometheus.md

- Increased the resources docker can use from the host ( memory 4 -> 7 gb) 

- https://blog.freshtracks.io/a-deep-dive-into-kubernetes-metrics-part-3-container-resource-metrics-361c5ee46e66

- EXPRESSIONS FOR CPU USAGE:
"expr": "sum(rate(container_cpu_usage_percentage_seconds_total{instance=~\"$host\",name=~\"$container\",name=~\".+\", name !~ \"(prometheus|cadvisor|grafana)\"}[10s])) by (name) *100",
"expr": "sum(rate(container_cpu_usage_percentage_seconds_total{instance=~\"$host\", name=~\"$container\", name !~ \"(prometheus|cadvisor|grafana)\"}[10s])) / sum(container_spec_cpu_quota{instance=~\"$host\", name=~\"$container\", name !~ \"(prometheus|cadvisor|grafana)\"} / container_spec_cpu_period{instance=~\"$host\", name=~\"$container\", name !~ \"(prometheus|cadvisor|grafana)\"}) by (name) *100",


- https://typeset.io/papers/fluid-mitigating-stragglers-in-federated-learning-using-3qo2tzhy
  says about a method beibg used for straggler mitigation in federated learning.(MAYBE USEFUL)

- https://github.com/google/cadvisor/issues/2026

- 
# flwr
# tensorflow==2.15.0
# tensorflow_probability==0.23.0
# tensorflow_privacy
# flask
# flask-restful
# flask_cors
# requests
# mlflow
# psutil
# scipy
# numpy
# sparse==0.13.0


{
    "epochs": 2,
    "batch_size": 64,
    "learning_rate": 0.2,
    "data_sample_percentage": 0.03,
    "freeze_layers_percentage": 0,
    "gradient_clipping_value": 6,
    "sparsification_enabled": false,
    "sparsification_method": "sparsity_threshold_bo_weight_magnitude",
    "sparsification_percentile": 95
}


  # Determine categories for each client
      1)  if self.client_id in [1, 4]:
            categories = [0,1,2,3,4,5]  # Categories for clients 1 and 4
      2)  elif self.client_id in [2]:
            categories = [0,1,2,3,4,5,6,7,8,9]  # Categories for client 2
      3)  elif self.client_id in [3]:
            categories = [0,1,2,3,4,5,6,7,8,9]  # Categories for client 3
        else:
            logger.error("Invalid client ID, categories cannot be assigned.")
            return

WITHOUT-TOOL:

when 1) is together with 2) and 3) with unlimited resources ( linear up to 0.6)
when 1) is alone graph is goes liner up to 0.3
when 1) is together with 2) and 3) but 2) and 3) have limited resources (so they do not participate in training -> client dropouts) then graph goes liner up to 0.3

TOOL-ENABLED:
I want to see if ->
when 1) is together with 2) and 3) but 2) and 3) have limited resources how the graph will adapt ? I hope to be in between 0.3 and 0.6




EXP:
tool-enabled (5categories for powerful clients, 10 for weak clients)